[{"E:\\Projects\\metro_maker\\src\\index.js":"1","E:\\Projects\\metro_maker\\src\\reportWebVitals.js":"2","E:\\Projects\\metro_maker\\src\\App.js":"3","E:\\Projects\\metro_maker\\src\\sidebar.js":"4","E:\\Projects\\metro_maker\\src\\components\\testButton.js":"5","E:\\Projects\\metro_maker\\src\\app\\store.js":"6","E:\\Projects\\metro_maker\\src\\reducers\\linesReducer.js":"7","E:\\Projects\\metro_maker\\src\\reducers\\servicesReducer.js":"8","E:\\Projects\\metro_maker\\src\\reducers\\rootReducer.js":"9","E:\\Projects\\metro_maker\\src\\actions\\actionTypes.js":"10","E:\\Projects\\metro_maker\\src\\actions\\lineActions.js":"11","E:\\Projects\\metro_maker\\src\\actions\\serviceActions.js":"12","E:\\Projects\\metro_maker\\src\\utils\\utils.js":"13","E:\\Projects\\metro_maker\\src\\actions\\agencyActions.js":"14","E:\\Projects\\metro_maker\\src\\reducers\\agenciesReducer.js":"15","E:\\Projects\\metro_maker\\src\\reducers\\serviceRouteReducer.js":"16","E:\\Projects\\metro_maker\\src\\reducers\\stationsReducer.js":"17","E:\\Projects\\metro_maker\\src\\reducers\\trackRouteReducer.js":"18","E:\\Projects\\metro_maker\\src\\reducers\\transferReducer.js":"19","E:\\Projects\\metro_maker\\src\\components\\managementPanel.js":"20","E:\\Projects\\metro_maker\\src\\components\\colorPickerButton.js":"21","E:\\Projects\\metro_maker\\src\\components\\colorPickerPopup.js":"22","E:\\Projects\\metro_maker\\src\\components\\addAgency.js":"23","E:\\Projects\\metro_maker\\src\\components\\agencyItem.js":"24"},{"size":4467,"mtime":1625152793344,"results":"25","hashOfConfig":"26"},{"size":362,"mtime":499162500000,"results":"27","hashOfConfig":"26"},{"size":264,"mtime":1625236016985,"results":"28","hashOfConfig":"26"},{"size":326,"mtime":1609641548714,"results":"29","hashOfConfig":"30"},{"size":663,"mtime":1625020278599,"results":"31","hashOfConfig":"26"},{"size":175,"mtime":1623273337278,"results":"32","hashOfConfig":"26"},{"size":2923,"mtime":1624994852683,"results":"33","hashOfConfig":"26"},{"size":3500,"mtime":1624994853554,"results":"34","hashOfConfig":"26"},{"size":3391,"mtime":1624994852104,"results":"35","hashOfConfig":"26"},{"size":3010,"mtime":1624166971936,"results":"36","hashOfConfig":"26"},{"size":2343,"mtime":1623387992004,"results":"37","hashOfConfig":"26"},{"size":2250,"mtime":1623387986580,"results":"38","hashOfConfig":"26"},{"size":3717,"mtime":1623702768258,"results":"39","hashOfConfig":"26"},{"size":2433,"mtime":1623388868882,"results":"40","hashOfConfig":"26"},{"size":1944,"mtime":1625017736643,"results":"41","hashOfConfig":"26"},{"size":16583,"mtime":1624976689091,"results":"42","hashOfConfig":"26"},{"size":2504,"mtime":1624974822057,"results":"43","hashOfConfig":"26"},{"size":18730,"mtime":1624974821466,"results":"44","hashOfConfig":"26"},{"size":3642,"mtime":1623552643632,"results":"45","hashOfConfig":"26"},{"size":1053,"mtime":1625270389803,"results":"46","hashOfConfig":"26"},{"size":1767,"mtime":1625270617065,"results":"47","hashOfConfig":"26"},{"size":142,"mtime":1625243680844,"results":"48","hashOfConfig":"26"},{"size":1674,"mtime":1625270364316,"results":"49","hashOfConfig":"26"},{"size":242,"mtime":1625270388075,"results":"50","hashOfConfig":"26"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"54"},"1xzmqcv",{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"e2pt3f",{"filePath":"61","messages":"62","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"54"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70","usedDeprecatedRules":"54"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81","usedDeprecatedRules":"54"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"88","usedDeprecatedRules":"54"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"93","usedDeprecatedRules":"54"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96","usedDeprecatedRules":"54"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"E:\\Projects\\metro_maker\\src\\index.js",["107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129"],"import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport { Provider } from 'react-redux';\r\nimport store from './app/store'\r\n\r\nimport {selectAgenciesLinesAndServicesAsTreeObject,selectLinesAndServicesAsTreeObject,selectServicesAsTreeObject} from './reducers/rootReducer'\r\nimport { addAgency, editAgency, removeAgency ,restoreAgency} from './actions/agencyActions';\r\nimport { addLine, editLine, removeLine ,restoreLine} from './actions/lineActions';\r\nimport { addService, editService, removeService, restoreService } from './actions/serviceActions';\r\nimport {filterDeleted, nextIDForArray} from './utils/utils'\r\nimport { selectServicesGivenLineID,selectServicesGivenAgencyID,serviceIDsGivenAgencyID } from './reducers/servicesReducer';\r\n\r\nimport { lineIDsGivenAgencyId,selectLinesGivenAgencyId } from './reducers/linesReducer';\r\n\r\n\r\n// store.dispatch(addAgency('go','green'));\r\n// store.dispatch(addAgency('ttc','red'));\r\n// store.dispatch(addAgency('yrt','cyan'));\r\n\r\n// store.dispatch(editAgency('2','yrt-viva','blue'));\r\n\r\n// store.dispatch(addLine('0','stouffville','brown','commuter/regional'));\r\n// store.dispatch(addLine('0','barrie','navy blue','commuter/regional'));\r\n// store.dispatch(addLine('0','lakeshore west','maroon','commuter/regional'));\r\n// store.dispatch(addLine('0','lakeshore east','orange-red','commuter/regional'));\r\n// store.dispatch(addLine('0','milfton','orange yellow','commuter/regional'));\r\n\r\n// store.dispatch(editLine('4','milton','orange yellow','commuter/regional'));\r\n\r\n// store.dispatch(addLine('1','yonge university','yellow','heavy metro'));\r\n// store.dispatch(addLine('1','sheppard','purple','heavy metro'));\r\n// store.dispatch(addLine('1','bloor danforth','green','heavy metro'));\r\n// store.dispatch(addLine('1','eglinton','orange','light metro'));\r\n// store.dispatch(addLine('1','scarborough','cyan','light metro'));\r\n\r\n// store.dispatch(addLine('2','viva blue','blue','brt'));\r\n// store.dispatch(addLine('2','viva purple','purple','brt'));\r\n// store.dispatch(addLine('2','viva green','lime green','brt'));\r\n// store.dispatch(addLine('2','viva yellow','yellow','brt'));\r\n\r\n// store.dispatch(addService('0','stouffville RER','express'));\r\n// store.dispatch(addService('0','stouffville commuter','peak only'));\r\n// store.dispatch(addService('1','barrie RER','express'));\r\n// store.dispatch(addService('1','barrie commuter','peak only'));\r\n// store.dispatch(addService('2','lakeshore west RER','express'));\r\n// store.dispatch(addService('2','lakeshore west commuter','peak only'));\r\n// store.dispatch(addService('3','lakeshore east RER','express'));\r\n// store.dispatch(addService('3','lakeshore east commuter','peak only'));\r\n// store.dispatch(addService('4','milton commuter','peak only'));\r\n\r\n// store.dispatch(addService('5','yonge university','local'));\r\n// store.dispatch(addService('6','sheppard','local'));\r\n// store.dispatch(addService('7','bloor danforth','local'));\r\n// store.dispatch(addService('8','eglinton','local'));\r\n// store.dispatch(addService('9','scarborough','local'));\r\n\r\n// store.dispatch(editService('9','yonge university spadina','local'));\r\n\r\n// store.dispatch(addService('10','bernard terminal','local'));\r\n// store.dispatch(addService('10','newmarket','express'));\r\n// store.dispatch(addService('11','richmond hill-mccowan','local'));\r\n// store.dispatch(addService('11','martin grove-mccowan','peak only'));\r\n\r\n// store.dispatch(removeService('14'));\r\n// store.dispatch(removeService('13'));\r\n// store.dispatch(removeLine('10'));\r\n// store.dispatch(removeAgency('0'));\r\n\r\n// // store.dispatch(addAgency('miway','orange'));\r\n\r\n// // store.dispatch(restoreService('14'));\r\n// // store.dispatch(restoreService('13'));\r\n// // store.dispatch(restoreLine('10'));\r\n// store.dispatch(restoreAgency('0'));\r\n// // store.dispatch(removeAgency('0'));\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store = {store}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// console.log(selectAgenciesLinesAndServicesAsTreeObject(store.getState(),false))\r\n// console.log(selectServicesGivenAgencyID(store.getState(),0,true))\r\n// console.log(selectServicesGivenAgencyID(store.getState(),0,false))\r\n\r\n\r\n// let testArray = [\r\n//   {id:0,deletedAt: null},\r\n//   {id:1,deletedAt: null},\r\n//   {id:2,deletedAt: null},\r\n//   {id:3,deletedAt: \"today\"},\r\n// ]\r\n",["130","131"],"E:\\Projects\\metro_maker\\src\\reportWebVitals.js",[],"E:\\Projects\\metro_maker\\src\\App.js",[],"E:\\Projects\\metro_maker\\src\\sidebar.js",[],"E:\\Projects\\metro_maker\\src\\components\\testButton.js",["132","133","134"],"E:\\Projects\\metro_maker\\src\\app\\store.js",[],"E:\\Projects\\metro_maker\\src\\reducers\\linesReducer.js",["135"],"import { filterById, filterDeleted, filterOutById, genericMultiDelete, genericMultiRestore, genericSingleDelete, genericSingleRestore, nextIDForArray } from '../utils/utils'\r\nimport {\r\n    ADD_LINE,\r\n    UNDO_ADD_LINE,\r\n    EDIT_LINE,\r\n    REMOVE_LINE,\r\n    RESTORE_LINE,\r\n    REMOVE_AGENCY,\r\n    RESTORE_AGENCY\r\n} from '../actions/actionTypes'\r\n\r\nconst initialLineState = [];\r\n\r\nexport default function lineReducer(state = initialLineState, action) {\r\n    switch (action.type) {\r\n        case ADD_LINE: {\r\n            return doAddLine(state, action);\r\n        }\r\n        case UNDO_ADD_LINE: {\r\n            return filterOutById(state, action.payload.id)\r\n        }\r\n        case EDIT_LINE: {\r\n            return doEditLine(state, action);\r\n        }\r\n        case REMOVE_AGENCY: {\r\n            return genericMultiDelete(\r\n                state,\r\n                action.payload.lineIDs,\r\n                action.payload.deletedAt\r\n            )\r\n        }\r\n        case REMOVE_LINE: {\r\n            return genericSingleDelete(\r\n                state,\r\n                action.payload.id,\r\n                action.payload.deletedAt\r\n            )\r\n        }\r\n        case RESTORE_AGENCY: {\r\n            return genericMultiRestore(\r\n                state,\r\n                action.payload.lineIDs\r\n            )\r\n        }\r\n        case RESTORE_LINE: {\r\n            return genericSingleRestore(\r\n                state,\r\n                action.payload.id\r\n            )\r\n        }\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction doAddLine(state, action) {\r\n    return [\r\n        ...state,\r\n        {\r\n            id: nextIDForArray(state),\r\n            agencyID: action.payload.agencyID,\r\n            name: action.payload.name,\r\n            color: action.payload.color,\r\n            linetype: action.payload.linetype,\r\n            deletedAt: null\r\n        }\r\n    ]\r\n}\r\n\r\nfunction doEditLine(state, action) {\r\n    return state.map(item => {\r\n        if (item.id != action.payload.id) {\r\n            return item\r\n        }\r\n        return {\r\n            ...item,\r\n            name: action.payload.name,\r\n            color: action.payload.color,\r\n            linetype: action.payload.linetype\r\n        }\r\n    })\r\n}\r\n\r\nexport function selectAllLines(lines, includeDeleted) {\r\n    return filterDeleted(lines, includeDeleted)\r\n}\r\n\r\nexport function selectLineGivenID(state, id, includeDeleted) {\r\n    let output = filterById(state.lines, id)\r\n    return filterDeleted(output, includeDeleted)\r\n}\r\n\r\nexport function selectLinesGivenAgencyId(state, agencyID, includeDeleted) {\r\n    let output = state.lines.filter(line => {\r\n        return line.agencyID === agencyID\r\n    })\r\n    return filterDeleted(output, includeDeleted)\r\n}\r\n\r\nexport function lineIDsGivenAgencyId(state, agencyID, includeDeleted) {\r\n    return selectLinesGivenAgencyId(state, agencyID, includeDeleted).map(line => {\r\n        return line.id\r\n    })\r\n}\r\n","E:\\Projects\\metro_maker\\src\\reducers\\servicesReducer.js",["136","137"],"import { filterById, filterDeleted, genericMultiDelete, genericMultiRestore, genericSingleDelete, genericSingleRestore, nextIDForArray } from '../utils/utils'\r\nimport { lineIDsGivenAgencyId } from './linesReducer.js'\r\nimport {\r\n    ADD_SERVICE,\r\n    EDIT_SERVICE,\r\n    REMOVE_SERVICE,\r\n    RESTORE_SERVICE,\r\n    REMOVE_LINE,\r\n    RESTORE_LINE,\r\n    REMOVE_AGENCY,\r\n    RESTORE_AGENCY\r\n} from '../actions/actionTypes'\r\n\r\nconst initialServicesState = []\r\n\r\nexport default function serviceReducer(state = initialServicesState, action) {\r\n    switch (action.type) {\r\n        case EDIT_SERVICE: {\r\n            return doEditService(state, action);\r\n        }\r\n        case REMOVE_AGENCY:\r\n        case REMOVE_LINE: {\r\n            return genericMultiDelete(\r\n                state,\r\n                action.payload.serviceIDs,\r\n                action.payload.deletedAt\r\n            )\r\n        }\r\n        case REMOVE_SERVICE: {\r\n            return genericSingleDelete(\r\n                state,\r\n                action.payload.id,\r\n                action.payload.deletedAt\r\n            )\r\n        }\r\n        case RESTORE_AGENCY:\r\n        case RESTORE_LINE: {\r\n            return genericMultiRestore(\r\n                state,\r\n                action.payload.serviceIDs\r\n            )\r\n        }\r\n\r\n        case RESTORE_SERVICE: {\r\n            return genericSingleRestore(\r\n                state,\r\n                action.payload.id\r\n            )\r\n        }\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport function doAddService(state, action) {\r\n    return [\r\n        ...state,\r\n        {\r\n            id: nextIDForArray(state),\r\n            lineID: action.payload.lineID,\r\n            name: action.payload.name,\r\n            servicePeriod: action.payload.servicePeriod,\r\n            frequency: action.payload.frequency,\r\n            deletedAt: null\r\n        }\r\n    ]\r\n}\r\n\r\nfunction doEditService(state, action) {\r\n    return state.map((item, index) => {\r\n        if (index !== action.payload.id) {\r\n            return item\r\n        }\r\n        return {\r\n            ...item,\r\n            name: action.payload.name,\r\n            servicePeriod: action.payload.servicePeriod,\r\n            frequency: action.payload.frequency\r\n        }\r\n    })\r\n}\r\n\r\nexport function selectAllServices(services, includeDeleted) {\r\n    return filterDeleted(services, includeDeleted)\r\n}\r\n\r\nexport function selectServiceGivenID(state, id, includeDeleted) {\r\n    let output = filterById(state.services, id)\r\n    return filterDeleted(output, includeDeleted)\r\n}\r\n\r\nexport function selectServicesGivenLineID(state, lineID, includeDeleted) {\r\n    let output = state.services.filter(service => {\r\n        return service.lineID == lineID\r\n    })\r\n    return filterDeleted(output, includeDeleted)\r\n}\r\n\r\nexport function serviceIDsGivenLineID(state, lineID, includeDeleted) {\r\n    return selectServicesGivenLineID(state, lineID, includeDeleted).map(service => {\r\n        return service.id\r\n    })\r\n}\r\n\r\nexport function selectServicesGivenAgencyID(state, agencyID, includeDeleted) {\r\n    let lineIDs = new Set(lineIDsGivenAgencyId(state, agencyID, includeDeleted))\r\n\r\n    let output = state.services.filter(service => {\r\n        return lineIDs.has(service.lineID)\r\n    })\r\n    return filterDeleted(output, includeDeleted)\r\n}\r\n\r\nexport function serviceIDsGivenAgencyID(state, agencyID, includeDeleted) {\r\n    return selectServicesGivenAgencyID(state, agencyID, includeDeleted).map(service => {\r\n        return service.id\r\n    })\r\n}\r\n","E:\\Projects\\metro_maker\\src\\reducers\\rootReducer.js",[],"E:\\Projects\\metro_maker\\src\\actions\\actionTypes.js",[],"E:\\Projects\\metro_maker\\src\\actions\\lineActions.js",[],"E:\\Projects\\metro_maker\\src\\actions\\serviceActions.js",[],"E:\\Projects\\metro_maker\\src\\utils\\utils.js",["138","139"],"/** \r\n * A class to contain random utility functions\r\n*/\r\n\r\nexport function nextIDForArray(array) {\r\n    const maxID = array.reduce((maxID, element) => Math.max(element.id, maxID), -1)\r\n    return maxID + 1\r\n};\r\n\r\nexport function genericSingleDelete(array, id, deletedAt) {\r\n    return array.map(item => {\r\n        if (item.id !== id) {\r\n            return item\r\n        }\r\n        return {\r\n            ...item,\r\n            deletedAt: deletedAt\r\n        }\r\n    })\r\n}\r\n\r\nexport function genericSingleRestore(array, id) {\r\n    return array.map(item => {\r\n        if (item.id !== id) {\r\n            return item\r\n        }\r\n        return {\r\n            ...item,\r\n            deletedAt: null\r\n        }\r\n    })\r\n}\r\n\r\nexport function genericMultiDelete(array, ids, deletedAt) {\r\n    var removeSet = new Set(ids)\r\n\r\n    return array.map((item) => {\r\n        if (removeSet.has(item.id)) {\r\n            return {\r\n                ...item,\r\n                deletedAt: deletedAt\r\n            }\r\n        } else {\r\n            return item\r\n        }\r\n    })\r\n}\r\n\r\nexport function genericMultiRestore(array, ids) {\r\n    var restoreSet = new Set(ids)\r\n\r\n    return array.map((item) => {\r\n        if (restoreSet.has(item.id)) {\r\n            return {\r\n                ...item,\r\n                deletedAt: null\r\n            }\r\n        } else {\r\n            return item\r\n        }\r\n    })\r\n}\r\n\r\nexport function filterDeleted(array, includeDeleted) {\r\n    if (includeDeleted === true) {\r\n        return array\r\n    }\r\n    return array.filter(item => {\r\n        return !item.deletedAt\r\n    })\r\n}\r\n\r\nexport function filterByIds(array, ids) {\r\n    var idset = new Set(ids)\r\n    return array.filter(item => {\r\n        return idset.has(item.id)\r\n    })\r\n}\r\n\r\n//basically get\r\nexport function filterById(array, id) {\r\n    return array.filter(item => {\r\n        return item.id === id\r\n    })\r\n}\r\n\r\nexport function getById(array, id) {\r\n    let searchID = parseInt(id)\r\n    let filtered = filterById(array, searchID)\r\n\r\n    if(filtered.length == 1) {\r\n        return filtered[0]\r\n    } else {\r\n        return {error: \"No item with such ID\"}\r\n    }\r\n}\r\n\r\nexport function filterOutById(array, id) {\r\n    return array.filter(item => {\r\n        return item.id !== id\r\n    })\r\n}\r\n\r\nexport function idCompareDsc(a,b) {\r\n    if(a.id < b.id) {\r\n        return 1;\r\n    }\r\n    if(a.id> b.id) {\r\n        return -1\r\n    }\r\n    return 0\r\n}\r\n\r\nexport function idCompareAsc(a,b) {\r\n    if(a.id < b.id) {\r\n        return -1;\r\n    }\r\n    if(a.id> b.id) {\r\n        return 1\r\n    }\r\n    return 0\r\n}\r\n\r\nexport function filterOutByIds(array, ids) {\r\n    var idset = new Set(ids)\r\n\r\n    return array.filter(item => {\r\n        return !idset.has(item.id)\r\n    })\r\n}\r\n\r\n\r\nexport function haversineMidpoint(node_A, node_B) {\r\n    const R = 6371e3\r\n    function toRad(x) {\r\n        return x * Math.PI / 180\r\n    }\r\n\r\n    //http://jsfiddle.net/c1s6xgab/\r\n    let lat1 = toRad(node_A.latitude)\r\n    let lng1 = toRad(node_A.longitude)\r\n\r\n    let lat2 = toRad(node_B.latitude)\r\n    let lng2 = toRad(node_B.longitude)\r\n\r\n    let dLng = (lng2 - lng1)\r\n\r\n    var bX = Math.cos(lat2) * Math.cos(dLng);\r\n    var bY = Math.cos(lat2) * Math.sin(dLng);\r\n\r\n    var lat3 = Math.atan2(Math.sin(lat1) + Math.sin(lat2), Math.sqrt((Math.cos(lat1) + bX) * (Math.cos(lat1) + bX) + bY * bY));\r\n    var lng3 = lng1 + Math.atan2(bY, Math.cos(lat1) + bX);\r\n\r\n    //Convert back into degrees\r\n    lat3 = lat3 * 180 / Math.PI\r\n    lng3 = lng3 * 180 / Math.PI\r\n\r\n    lng3 = ( lng3 + 540 ) % 360 - 180\r\n\r\n    // 6 digits of precision is precision at worst of 11cm at equator \r\n    return {\r\n        latitude: parseFloat(lat3.toFixed(6)) ,\r\n        longitude: parseFloat(lng3.toFixed(6)) \r\n    }\r\n}\r\n","E:\\Projects\\metro_maker\\src\\actions\\agencyActions.js",[],"E:\\Projects\\metro_maker\\src\\reducers\\agenciesReducer.js",[],"E:\\Projects\\metro_maker\\src\\reducers\\serviceRouteReducer.js",["140","141","142","143","144","145","146","147","148"],"import { filterById, genericMultiDelete, genericMultiRestore, genericSingleDelete, genericSingleRestore, nextIDForArray } from '../utils/utils'\r\nimport {\r\n    REMOVE_SERVICE, RESTORE_SERVICE,\r\n    REMOVE_LINE, RESTORE_LINE,\r\n    REMOVE_AGENCY, RESTORE_AGENCY,\r\n\r\n    ADD_SERVICETRACK_TWOWAY,\r\n    ADD_SERVICETRACK_ONEWAY,\r\n    SWITCH_ONEWAY_DIRECTION,\r\n    ONEWAY_TO_TWOWAY,\r\n    TWOWAY_TO_ONEWAY,\r\n    REMOVE_SERVICE_ALONG_TRACK,\r\n    CLEAR_SERVICE_ROUTE,\r\n    UNDO_CLEAR_SERVICE_ROUTE,\r\n    REMOVE_STOP,\r\n    RESTORE_STOP\r\n} from '../actions/actionTypes'\r\nimport _, { difference, union } from 'underscore';\r\n\r\n//an array of serviceRoute objects\r\nconst initialState = [];\r\n\r\n/* \r\n    A service route object stores three things\r\n    1. The service runs along which tracks \r\n        (by extension passes through which stations)\r\n    2. The service stops at which stations\r\n    3. The order and grouping of service route\r\n\r\n    e.g.\r\n    A<->B is represented as \r\n\r\n    A->B, A<-B\r\n\r\n    If there were a section of track like this\r\n\r\n    A <-- B1 <-- C\r\n     \\--> B2 --/\r\n\r\n    That is represented within the track block as\r\n\r\n    A <- B1, B1 <- C\r\n    A -> B2, B2 -> C\r\n\r\n    or more specifically\r\n\r\n    trackID: 1, fromID: A, toID: B2\r\n    trackID: 2, fromID: B2, toID: C\r\n    trackID: 3, fromID: C, toID: B1\r\n    trackID: 4, fromID: B1, toID: A\r\n\r\n    Also you can only add or delete from a service at the ends.\r\n    \r\n    4. A trackBlock stores the stations that it contains, the service tracks and the completeness/ validity of the block.\r\n\r\n    If a block is not a perfect cycle then complete is false.\r\n\r\n    A block must be complete before a new block can be added on top of it\r\n*/\r\n\r\n\r\nexport default function serviceRouteReducer(state = initialState, action) {\r\n    switch (action.type) {\r\n        case REMOVE_AGENCY:\r\n        case REMOVE_LINE: {\r\n            return genericMultiDelete(\r\n                state,\r\n                action.payload.serviceIDs,\r\n                action.payload.deletedAt\r\n            )\r\n        }\r\n        case REMOVE_SERVICE: {\r\n            return genericSingleDelete(\r\n                state,\r\n                action.payload.id,\r\n                action.payload.deletedAt\r\n            )\r\n        }\r\n        case RESTORE_AGENCY:\r\n        case RESTORE_LINE: {\r\n            return genericMultiRestore(\r\n                state,\r\n                action.payload.serviceIDs\r\n            )\r\n        }\r\n        case RESTORE_SERVICE: {\r\n            return genericSingleRestore(\r\n                state,\r\n                action.payload.id\r\n            )\r\n        }\r\n        case ADD_SERVICETRACK_TWOWAY: {\r\n            return doAddTwoWayServiceTrack(state, action)\r\n        }\r\n        case ADD_SERVICETRACK_ONEWAY: {\r\n            return doAddOneWayServiceTrack(state, action)\r\n        }\r\n        case SWITCH_ONEWAY_DIRECTION: {\r\n            return editServiceTracks(state, action, matchingTrackIDPredicate, (targetEdges) => {\r\n                return targetEdges.length !== 1\r\n            }, doSwitchOneWayDirection)\r\n        }\r\n        case ONEWAY_TO_TWOWAY: {\r\n            return editServiceTracks(state, action, matchingTrackIDPredicate, (targetEdges) => {\r\n                return targetEdges.length !== 1\r\n            }, doOneWayToTwoWay)\r\n        }\r\n        case TWOWAY_TO_ONEWAY: {\r\n            return editServiceTracks(state, action, matchingTrackIDPredicate, (targetEdges) => {\r\n                return targetEdges.length !== 2\r\n            }, doTwoWayToOneWay)\r\n        }\r\n        case REMOVE_SERVICE_ALONG_TRACK: {\r\n            return editServiceTracks(state, action, matchingTrackIDPredicate, (targetEdges) => {\r\n                return targetEdges.length === 0\r\n            }, doRemoveServiceAlongTrack)\r\n        }\r\n        case CLEAR_SERVICE_ROUTE: {\r\n            return doClearServiceRoute(state, action)\r\n        }\r\n        case UNDO_CLEAR_SERVICE_ROUTE: {\r\n            return doUndoClearServiceRoute(state, action)\r\n        }\r\n        case REMOVE_STOP: {\r\n            return doRemoveStop(state, action)\r\n        }\r\n        case RESTORE_STOP: {\r\n            return doRestoreStop(state, action)\r\n        }\r\n        default:\r\n            return state;\r\n    }\r\n\r\n}\r\n\r\nexport function doAddServiceRoute(state, serviceID) {\r\n    return [\r\n        ...state,\r\n        {\r\n            //serviceID\r\n            id: serviceID,\r\n            deletedAt: null,\r\n            stopsByID: [],\r\n            serviceTracks: []\r\n        }\r\n    ]\r\n}\r\n\r\nfunction doAddTwoWayServiceTrack(state, action) {\r\n    return state.map(serviceRoute => {\r\n        if (serviceRoute.id !== action.payload.serviceID) {\r\n            return serviceRoute\r\n        }\r\n\r\n        let newStops = serviceRoute.stopsByID.slice(0);\r\n\r\n        newStops = union(newStops, action.payload.stationIDs)\r\n\r\n        let serviceTracks = serviceRoute.serviceTracks.slice(0);\r\n\r\n        let newBlock = [\r\n            {\r\n                trackID: action.payload.trackID,\r\n                fromStationID: parseInt(action.payload.stationIDs[0]),\r\n                toStationID: parseInt(action.payload.stationIDs[1])\r\n            },\r\n            {\r\n                trackID: action.payload.trackID,\r\n                fromStationID: parseInt(action.payload.stationIDs[1]),\r\n                toStationID: parseInt(action.payload.stationIDs[0])\r\n            }\r\n        ];\r\n\r\n        serviceTracks.splice(action.payload.index, 0, newBlock)\r\n\r\n        return {\r\n            ...serviceRoute,\r\n            stopsByID: newStops,\r\n            serviceTracks: serviceTracks\r\n        }\r\n    })\r\n}\r\n\r\nfunction doAddOneWayServiceTrack(state, action) {\r\n    return state.map(serviceRoute => {\r\n        if (serviceRoute.id !== action.payload.serviceID) {\r\n            return serviceRoute\r\n        }\r\n\r\n        let newStops = serviceRoute.stopsByID.slice(0)\r\n        if (newStops.indexOf(action.payload.fromID) === -1) {\r\n            newStops.push(action.payload.fromID)\r\n        }\r\n        if (newStops.indexOf(action.payload.toID) === -1) {\r\n            newStops.push(action.payload.toID)\r\n        }\r\n        let serviceTracks = serviceRoute.serviceTracks.slice(0)\r\n\r\n        // if inserting at the beginning, the index is -1. \r\n        if (serviceTracks.length === action.payload.index) {\r\n            let newBlock = [\r\n                {\r\n                    trackID: action.payload.trackID,\r\n                    fromStationID: action.payload.fromID,\r\n                    toStationID: action.payload.toID\r\n                }];\r\n            serviceTracks.splice(action.payload.index, 0, newBlock)\r\n\r\n        } else if (action.payload.index === -1) {\r\n            let newBlock = [\r\n                {\r\n                    trackID: action.payload.trackID,\r\n                    fromStationID: action.payload.fromID,\r\n                    toStationID: action.payload.toID\r\n                }];\r\n            serviceTracks.splice(0, 0, newBlock)\r\n        } else {\r\n            let currentBlock = serviceTracks[action.payload.index].slice(0)\r\n\r\n            // Adding to a complete block is not allowed\r\n            if (!isTrackBlockComplete(currentBlock)) {\r\n                currentBlock.push({\r\n                    trackID: action.payload.trackID,\r\n                    fromStationID: action.payload.fromID,\r\n                    toStationID: action.payload.toID\r\n                })\r\n                serviceTracks.splice(action.payload.index, 1, currentBlock)\r\n            } else {\r\n                return {\r\n                    ...serviceRoute\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            ...serviceRoute,\r\n            stopsByID: newStops,\r\n            serviceTracks: serviceTracks\r\n        }\r\n    })\r\n}\r\n\r\nfunction editServiceTracks(state, action, targetEdgePredicate, predicate, callback) {\r\n    return state.map(serviceRoute => {\r\n        if (serviceRoute.id !== action.payload.serviceID) {\r\n            return serviceRoute\r\n        }\r\n\r\n        let serviceTracks = serviceRoute.serviceTracks.slice(0)\r\n        if (action.payload.index >= serviceTracks.length || action.payload.index < 0) {\r\n            return serviceRoute\r\n        }\r\n        let targetBlock = serviceTracks[action.payload.index]\r\n\r\n        let targetEdges = targetBlock.filter(edge => targetEdgePredicate(action, edge))\r\n\r\n        if (predicate(targetEdges)) {\r\n            return serviceRoute\r\n        } else {\r\n            return callback(serviceRoute, action, serviceTracks, targetBlock, targetEdges)\r\n        }\r\n    })\r\n}\r\n\r\nfunction matchingTrackIDPredicate(action, edge) {\r\n    return edge.trackID === action.payload.trackID\r\n}\r\n\r\nfunction doSwitchOneWayDirection(serviceRoute, action, serviceTracks, targetBlock, targetEdges) {\r\n    let newBlock = targetBlock.filter(edge => {\r\n        return edge.trackID !== action.payload.trackID\r\n    }).slice(0)\r\n\r\n    let targetEdge = targetEdges[0]\r\n\r\n    let newEdge = {\r\n        trackID: targetEdge.trackID,\r\n        fromStationID: targetEdge.toStationID,\r\n        toStationID: targetEdge.fromStationID\r\n    }\r\n\r\n    newBlock.push(newEdge)\r\n    serviceTracks.splice(action.payload.index, 1, newBlock)\r\n\r\n    return {\r\n        ...serviceRoute,\r\n        serviceTracks: serviceTracks\r\n    }\r\n}\r\n\r\nfunction doOneWayToTwoWay(serviceRoute, action, serviceTracks, targetBlock, targetEdges) {\r\n    let targetEdge = targetEdges[0]\r\n\r\n    let newBlock = [\r\n        {\r\n            trackID: action.payload.trackID,\r\n            fromStationID: parseInt(targetEdge.fromStationID),\r\n            toStationID: parseInt(targetEdge.toStationID)\r\n        },\r\n        {\r\n            trackID: action.payload.trackID,\r\n            fromStationID: parseInt(targetEdge.toStationID),\r\n            toStationID: parseInt(targetEdge.fromStationID)\r\n        }\r\n    ]\r\n    serviceTracks.splice(action.payload.index, 1, newBlock)\r\n    return {\r\n        ...serviceRoute,\r\n        serviceTracks: serviceTracks\r\n    }\r\n}\r\n\r\nfunction doTwoWayToOneWay(serviceRoute, action, serviceTracks, targetBlock, targetEdges) {\r\n    let targetEdge = targetEdges[0]\r\n\r\n    let newBlock = [\r\n        {\r\n            trackID: action.payload.trackID,\r\n            fromStationID: parseInt(targetEdge.fromStationID),\r\n            toStationID: parseInt(targetEdge.toStationID)\r\n        }\r\n    ]\r\n    serviceTracks.splice(action.payload.index, 1, newBlock)\r\n    return {\r\n        ...serviceRoute,\r\n        serviceTracks: serviceTracks\r\n    }\r\n}\r\n\r\nfunction doRemoveServiceAlongTrack(serviceRoute, action, serviceTracks, targetBlock, targetEdges) {\r\n    let checkStops = []\r\n\r\n    let newBlock = targetBlock.filter(edge => {\r\n        if (edge.trackID === action.payload.trackID) {\r\n            checkStops = [edge.fromStationID, edge.toStationID]\r\n        }\r\n        return edge.trackID !== action.payload.trackID\r\n    })\r\n\r\n    if (newBlock.length > 0) {\r\n        serviceTracks.splice(action.payload.index, 1, newBlock)\r\n    } else {\r\n        serviceTracks = [\r\n            ...serviceTracks.slice(0, action.payload.index),\r\n            ...serviceTracks.slice(action.payload.index + 1)\r\n        ]\r\n    }\r\n\r\n    let removeStops = []\r\n\r\n    if (!serviceRoutePassesThroughStation(serviceTracks, checkStops[0])) {\r\n        removeStops.push(checkStops[0])\r\n    }\r\n    if (!serviceRoutePassesThroughStation(serviceTracks, checkStops[1])) {\r\n        removeStops.push(checkStops[1])\r\n    }\r\n    let newStops = difference(serviceRoute.stopsByID, removeStops)\r\n    return {\r\n        ...serviceRoute,\r\n        stopsByID: newStops,\r\n        serviceTracks: serviceTracks\r\n    }\r\n}\r\n\r\nexport function doClearServiceRoute(state, action) {\r\n    return state.map(serviceRoute => {\r\n        if (serviceRoute.id !== action.payload.serviceID) {\r\n            return serviceRoute\r\n        }\r\n        return {\r\n            ...serviceRoute,\r\n            stopsByID: [],\r\n            serviceTracks: []\r\n        }\r\n    })\r\n}\r\n\r\nexport function doUndoClearServiceRoute(state, action) {\r\n    return state.map(serviceRoute => {\r\n        if (serviceRoute.id !== action.payload.serviceID) {\r\n            return serviceRoute\r\n        }\r\n        return {\r\n            ...serviceRoute,\r\n            stopsByID: action.payload.stops,\r\n            serviceTracks: action.payload.serviceTracks\r\n        }\r\n    })\r\n}\r\n\r\nfunction doRemoveStop(state, action) {\r\n    return state.map(serviceRoute => {\r\n        if (serviceRoute.id !== action.payload.serviceID) {\r\n            return serviceRoute\r\n        }\r\n        let newStopsByID = serviceRoute.stopsByID.filter(stop => {\r\n            return stop !== action.payload.stationID\r\n        })\r\n        return {\r\n            ...serviceRoute,\r\n            stopsByID: newStopsByID\r\n        }\r\n    })\r\n}\r\n\r\nfunction doRestoreStop(state, action) {\r\n    return state.map(serviceRoute => {\r\n        if (serviceRoute.id !== action.payload.serviceID) {\r\n            return serviceRoute\r\n        }\r\n        if (!serviceRoutePassesThroughStation(serviceRoute.serviceTracks, action.payload.stationID)) {\r\n            return serviceRoute\r\n        }\r\n\r\n        let newStopsByID = serviceRoute.stopsByID.slice(0)\r\n        newStopsByID.push(action.payload.stationID)\r\n        newStopsByID.sort((a, b) => a - b)\r\n        return {\r\n            ...serviceRoute,\r\n            stopsByID: newStopsByID\r\n        }\r\n    })\r\n\r\n}\r\n\r\nexport function serviceRoutePassesThroughStation(serviceTracks, stationID) {\r\n\r\n    for (var i = 0; i < serviceTracks.length; i++) {\r\n        for (var j = 0; j < serviceTracks[i].length; j++) {\r\n            let edge = serviceTracks[i][j]\r\n            if (edge.fromStationID === stationID || edge.toStationID === stationID) {\r\n                return true\r\n            }\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nfunction validActionsForServiceRoute(serviceRoute, stations) {\r\n    //so when the serviceRoute is empty, this is not called.\r\n\r\n    // stationIDs where a new block can be added, along with the associated trackBlockIndex\r\n    // stationIds where an incomplete block can be added to, needs associated trackBlockIndex\r\n    // trackBlockIndices which are not complete and can be edited\r\n}\r\n\r\nexport function isTrackBlockAtIndexComplete(serviceRoute, serviceID, index) {\r\n    let targetServiceRoute = filterById(serviceRoute, serviceID)[0]\r\n\r\n    if (!targetServiceRoute) {\r\n        return false\r\n    }\r\n\r\n    let targetBlock = targetServiceRoute.serviceTracks[index]\r\n    return isTrackBlockComplete(targetBlock)\r\n}\r\n\r\nexport function isTrackBlockComplete(targetBlock) {\r\n    if (!targetBlock || targetBlock.length == 0) {\r\n        return false\r\n    }\r\n\r\n    let fromIDs = new Set()\r\n    let toIDs = new Set()\r\n\r\n    for (var i = 0; i < targetBlock.length; i++) {\r\n        let edge = targetBlock[i]\r\n        let from = edge.fromStationID\r\n        let to = edge.toStationID\r\n\r\n        if (from !== to) {\r\n            if (toIDs.has(from)) {\r\n                toIDs.delete(from)\r\n            } else {\r\n                fromIDs.add(from)\r\n            }\r\n\r\n            if (fromIDs.has(to)) {\r\n                fromIDs.delete(to)\r\n            } else {\r\n                toIDs.add(to)\r\n            }\r\n        }\r\n    }\r\n    return fromIDs.size === 0 && toIDs.size === 0\r\n}\r\n\r\nfunction isServiceRouteComplete(serviceRoute) {\r\n    //check, all stations in servicetracks = stops + passthrough\r\n    //check, each track block complete\r\n}\r\n\r\nfunction getStationsInOrder(serviceRoute) {\r\n    // first station is the station in the first track block that isn't in the next block\r\n}\r\n\r\nexport function stationCanBeDeleted(state, stationID) {\r\n    return checkIfTrackOrStationCanBeDeleted(state, stationID, (edge, stationID) => {\r\n        return edge.fromStationID == stationID || edge.toStationID == stationID\r\n    })\r\n}\r\n\r\nexport function trackCanBeDeleted(state, trackID) {\r\n    return checkIfTrackOrStationCanBeDeleted(state, trackID, (edge, trackID) => {\r\n        return edge.trackID == trackID\r\n    })\r\n}\r\n\r\nfunction checkIfTrackOrStationCanBeDeleted(state, removeID, predicate) {\r\n    let canBeDeleted = true\r\n    let serviceSet = new Set()\r\n\r\n    for (var i = 0; i < state.length; i++) {\r\n        let serviceRoute = state[i]\r\n\r\n        for (var j = 0; j < serviceRoute.serviceTracks.length; j++) {\r\n            let block = serviceRoute.serviceTracks[j]\r\n            for (var k = 0; k < block.length; k++) {\r\n                let edge = block[k]\r\n\r\n                if (predicate(edge, removeID)) {\r\n                    canBeDeleted = false\r\n                    serviceSet.add(serviceRoute.id)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        canBeDeleted: canBeDeleted,\r\n        serviceIDs: Array.from(serviceSet)\r\n    }\r\n}\r\n","E:\\Projects\\metro_maker\\src\\reducers\\stationsReducer.js",[],"E:\\Projects\\metro_maker\\src\\reducers\\trackRouteReducer.js",["149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170"],"import { difference, intersection, object, union } from 'underscore'\r\nimport {\r\n    genericMultiDelete,\r\n    genericMultiRestore,\r\n    genericSingleDelete,\r\n    genericSingleRestore,\r\n    haversineMidpoint,\r\n    nextIDForArray,\r\n    filterDeleted,\r\n    filterByIds,\r\n    filterOutById,\r\n    filterOutByIds,\r\n    idCompareAsc,\r\n    getById\r\n} from '../utils/utils'\r\nimport {\r\n    ADD_TRACK,\r\n    UNDO_ADD_TRACK,\r\n    REMOVE_TRACK,\r\n    RESTORE_TRACK,\r\n\r\n    REMOVE_STATION,\r\n    RESTORE_STATION,\r\n\r\n    MOVE_NODE,\r\n    MOVE_STATION,\r\n\r\n    ADD_STRAIGHT_SEGMENT,\r\n    ADD_CURVED_SEGMENT,\r\n    STRAIGHT_TO_CURVED,\r\n    CURVED_TO_STRAIGHT,\r\n\r\n    BREAK_SEGMENT,\r\n    UNDO_BREAK_SEGMENT,\r\n    MERGE_SEGMENTS,\r\n    UNDO_MERGE_SEGMENTS,\r\n\r\n    REMOVE_SEGMENT,\r\n    RESTORE_SEGMENT,\r\n} from '../actions/actionTypes'\r\n\r\n/**\r\n * id: int\r\n * stationIDs: [0, 1]\r\n * nodes: [ {id, lat, long, stationID}, {id, lat, long}]\r\n * segments: [{id, endpoints:[id, id]}]\r\n * deletedAt:\r\n */\r\n\r\n\r\nconst initialState = []\r\n\r\nexport default function trackRouteReducer(state = initialState, action) {\r\n    switch (action.type) {\r\n        case ADD_TRACK: {\r\n            return doAddTrackRoute(state, action)\r\n        }\r\n        case UNDO_ADD_TRACK: {\r\n            return filterOutById(state, action.payload.id)\r\n        }\r\n        case ADD_STRAIGHT_SEGMENT:\r\n        case ADD_CURVED_SEGMENT: {\r\n            return doAddSegmentToTrackRoute(state, action)\r\n        }\r\n        case STRAIGHT_TO_CURVED: {\r\n            return doStraightToCurved(state, action)\r\n        }\r\n        case CURVED_TO_STRAIGHT: {\r\n            return doCurvedToStraight(state, action)\r\n        }\r\n        case BREAK_SEGMENT: {\r\n            return doBreakSegment(state, action)\r\n        }\r\n        case UNDO_BREAK_SEGMENT: {\r\n            return undoBreakSegment(state, action)\r\n        }\r\n        case MERGE_SEGMENTS: {\r\n            return doMergeSegments(state, action)\r\n        }\r\n        case UNDO_MERGE_SEGMENTS: {\r\n            return undoMergeSegments(state, action)\r\n        }\r\n        case REMOVE_SEGMENT: {\r\n            return doRemoveSegment(state, action)\r\n        }\r\n        case RESTORE_SEGMENT: {\r\n            return doRestoreSegment(state, action)\r\n        }\r\n        //This can only happen if track doesn't have services running on it\r\n        case REMOVE_TRACK: {\r\n            return genericSingleDelete(\r\n                state,\r\n                action.payload.id,\r\n                action.payload.deletedAt\r\n            )\r\n        }\r\n        case RESTORE_TRACK: {\r\n            return genericSingleRestore(\r\n                state,\r\n                action.payload.id\r\n            )\r\n        }\r\n        case REMOVE_STATION: {\r\n            return genericMultiDelete(\r\n                state,\r\n                action.payload.trackIDs,\r\n                action.payload.deletedAt\r\n            )\r\n        }\r\n        case RESTORE_STATION: {\r\n            return genericMultiRestore(\r\n                state,\r\n                action.payload.trackIDs\r\n            )\r\n        }\r\n        case MOVE_NODE: {\r\n            return doMoveNode(state, action)\r\n        }\r\n        case MOVE_STATION: {\r\n            return doMoveStation(state, action)\r\n        }\r\n        default:\r\n            return state\r\n    }\r\n}\r\n\r\n\r\n// Add Track\r\nexport function doAddTrackRoute(state, action) {\r\n    let trackID = nextIDForArray(state)\r\n\r\n    let stations = action.payload.stations\r\n\r\n    return [\r\n        ...state,\r\n        {\r\n            id: trackID,\r\n            stationIDs: [stations[0].id, stations[1].id],\r\n            nodes: [\r\n                {\r\n                    id: 0,\r\n                    stationID: stations[0].id,\r\n                    latitude: stations[0].latitude,\r\n                    longitude: stations[0].longitude\r\n                },\r\n                {\r\n                    id: 1,\r\n                    stationID: stations[1].id,\r\n                    latitude: stations[1].latitude,\r\n                    longitude: stations[1].longitude\r\n                }\r\n            ],\r\n            segments: [\r\n                {\r\n                    id: 0,\r\n                    isCurved: false,\r\n                    endNodes: [0, 1],\r\n                    controlPoint: null\r\n                }\r\n            ],\r\n            deletedAt: null\r\n        }\r\n    ]\r\n}\r\n\r\nfunction doAddSegmentToTrackRoute(state, action) {\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.id != action.payload.trackID) {\r\n            return trackRoute\r\n        }\r\n        let givenNodeIDs = action.payload.nodeIDs\r\n        let newNodeID = nextIDForArray(trackRoute.nodes)\r\n        let newNodes = trackRoute.nodes.slice(0)\r\n\r\n        for (var i = 0; i < givenNodeIDs.length; i++) {\r\n            if (givenNodeIDs[i] == null) {\r\n                givenNodeIDs[i] = newNodeID\r\n                newNodes.push({\r\n                    id: newNodeID,\r\n                    stationID: null,\r\n                    latitude: action.payload.latitudes[i],\r\n                    longitude: action.payload.longitudes[i],\r\n                })\r\n                newNodeID = newNodeID + 1\r\n            }\r\n        }\r\n\r\n        let controlPoint = null\r\n        let isCurved = false;\r\n        if (action.type === ADD_CURVED_SEGMENT) {\r\n            controlPoint = givenNodeIDs[2]\r\n            isCurved = true\r\n        }\r\n        let newSegmentID = nextIDForArray(trackRoute.segments)\r\n\r\n        let newSegments = trackRoute.segments.slice(0)\r\n        newSegments.push(\r\n            {\r\n                id: newSegmentID,\r\n                isCurved: isCurved,\r\n                endNodes: [givenNodeIDs[0], givenNodeIDs[1]],\r\n                controlPoint: controlPoint\r\n            }\r\n        )\r\n        return {\r\n            ...trackRoute,\r\n            nodes: newNodes,\r\n            segments: newSegments\r\n        }\r\n    })\r\n}\r\n\r\nfunction doStraightToCurved(state, action) {\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.id != action.payload.trackID) {\r\n            return trackRoute\r\n        }\r\n\r\n        let newNodes = trackRoute.nodes.slice(0)\r\n        let newSegments = trackRoute.segments.slice(0)\r\n\r\n        let targetSegment = trackRoute.segments[action.payload.id]\r\n\r\n        if (!targetSegment.controlPoint) {\r\n            let newCoords = haversineMidpoint(\r\n                newNodes[targetSegment.endNodes[0]],\r\n                newNodes[targetSegment.endNodes[1]]\r\n            )\r\n            let newNodeID = nextIDForArray(newNodes)\r\n\r\n            newNodes.push({\r\n                id: newNodeID,\r\n                stationID: null,\r\n                latitude: newCoords.latitude,\r\n                longitude: newCoords.longitude\r\n            })\r\n\r\n            newSegments = newSegments.map(segment => {\r\n                if (segment.id != action.payload.id) {\r\n                    return segment\r\n                }\r\n                return {\r\n                    ...segment,\r\n                    isCurved: true,\r\n                    controlPoint: newNodeID\r\n                }\r\n            })\r\n        } else {\r\n            newSegments = newSegments.map(segment => {\r\n                if (segment.id != action.payload.id) {\r\n                    return segment\r\n                }\r\n                return {\r\n                    ...segment,\r\n                    isCurved: true\r\n                }\r\n            })\r\n        }\r\n\r\n        return {\r\n            ...trackRoute,\r\n            nodes: newNodes,\r\n            segments: newSegments\r\n        }\r\n    })\r\n}\r\n\r\nfunction doCurvedToStraight(state, action) {\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.id != action.payload.trackID) {\r\n            return trackRoute\r\n        }\r\n        let newSegments = trackRoute.segments.slice(0)\r\n\r\n        newSegments = newSegments.map(segment => {\r\n            if (segment.id !== action.payload.id) {\r\n                return segment\r\n            }\r\n            return {\r\n                ...segment,\r\n                isCurved: false\r\n            }\r\n        })\r\n\r\n        return {\r\n            ...trackRoute,\r\n            segments: newSegments\r\n        }\r\n    })\r\n}\r\n\r\nfunction doBreakSegment(state, action) {\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.id != action.payload.trackID) {\r\n            return trackRoute\r\n        }\r\n\r\n        let targetSegment = trackRoute.segments[action.payload.segmentID]\r\n\r\n        //remove target segment\r\n        let removedParentSegment = removeSegmentsFromTrackRoute(\r\n            trackRoute.nodes,\r\n            trackRoute.segments,\r\n            [action.payload.segmentID]\r\n        )\r\n\r\n        let newNodes = removedParentSegment.nodes\r\n        let newSegments = removedParentSegment.segments\r\n\r\n        // get the end nodes of the removed segment to construct two children segments\r\n        let segmentEndNodes = filterByIds(newNodes, targetSegment.endNodes)\r\n\r\n        let newCoords = haversineMidpoint(\r\n            segmentEndNodes[0],\r\n            segmentEndNodes[1]\r\n        )\r\n        let newNodeID = nextIDForArray(newNodes)\r\n        newNodes.push({\r\n            id: newNodeID,\r\n            stationID: null,\r\n            latitude: newCoords.latitude,\r\n            longitude: newCoords.longitude\r\n        })\r\n\r\n        // push the new segments\r\n        newSegments.push({\r\n            id: targetSegment.id,\r\n            endNodes: [targetSegment.endNodes[0], newNodeID],\r\n            isCurved: false,\r\n            controlPoint: null,\r\n        })\r\n\r\n        newSegments.push({\r\n            id: nextIDForArray(newSegments),\r\n            endNodes: [newNodeID, targetSegment.endNodes[1]],\r\n            isCurved: false,\r\n            controlPoint: null,\r\n        })\r\n        newSegments.sort(idCompareAsc)\r\n\r\n        return {\r\n            ...trackRoute,\r\n            nodes: newNodes,\r\n            segments: newSegments\r\n        }\r\n    })\r\n}\r\n\r\nfunction undoBreakSegment(state, action) {\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.id != action.payload.trackID) {\r\n            return trackRoute\r\n        }\r\n        let removeParentsSegments = removeSegmentsFromTrackRoute(\r\n            trackRoute.nodes,\r\n            trackRoute.segments,\r\n            action.payload.segmentIDs\r\n        )\r\n\r\n        let newNodes = removeParentsSegments.nodes\r\n        let newSegments = removeParentsSegments.segments\r\n\r\n        if(action.payload.nodeToRestore) {\r\n            newNodes.push(action.payload.nodeToRestore)\r\n            newNodes.sort(idCompareAsc)\r\n        }\r\n        newSegments.push(action.payload.segmentToRestore)\r\n        newSegments.sort(idCompareAsc)\r\n\r\n        return {\r\n            ...trackRoute,\r\n            nodes: newNodes,\r\n            segments: newSegments\r\n        }\r\n    })\r\n}\r\n\r\nfunction doMergeSegments(state, action) {\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.id != action.payload.trackID) {\r\n            return trackRoute\r\n        }\r\n\r\n        let commonNodes = getCommonEndPointsBetweenTwoSegments(\r\n            action.payload.segmentIDs[0],\r\n            action.payload.segmentIDs[1],\r\n            trackRoute.segments\r\n        )\r\n\r\n        // if two segments dont touch\r\n        if (commonNodes.length != 1) {\r\n            return trackRoute\r\n        }\r\n\r\n        let mergeEndPoints = getUnCommonEndPointsBetweenTwoSegments(\r\n            action.payload.segmentIDs[0],\r\n            action.payload.segmentIDs[1],\r\n            trackRoute.segments\r\n        )\r\n\r\n        let removedParentSegments = removeSegmentsFromTrackRoute(\r\n            trackRoute.nodes,\r\n            trackRoute.segments,\r\n            action.payload.segmentIDs\r\n        )\r\n\r\n        let newNodes = removedParentSegments.nodes\r\n        let newSegments = removedParentSegments.segments\r\n\r\n\r\n        newSegments.push({\r\n            id: action.payload.segmentIDs[0],\r\n            endNodes: mergeEndPoints,\r\n            isCurved: false,\r\n            controlPoint: null,\r\n        })\r\n\r\n        newSegments.sort(idCompareAsc)\r\n\r\n        return {\r\n            ...trackRoute,\r\n            nodes: newNodes,\r\n            segments: newSegments,\r\n        }\r\n    })\r\n}\r\n\r\nfunction undoMergeSegments(state, action) {\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.id != action.payload.trackID) {\r\n            return trackRoute\r\n        }\r\n\r\n        let removedParentSegment = removeSegmentsFromTrackRoute(\r\n            trackRoute.nodes,\r\n            trackRoute.segments,\r\n            [action.payload.segmentToRemoveID]\r\n        )\r\n        let newNodesAndSegments = restoreSegmentsAndNodes(\r\n            removedParentSegment.nodes,\r\n            removedParentSegment.segments,\r\n            action.payload.nodesToRestore,\r\n            action.payload.segmentsToRestore\r\n        )\r\n\r\n        return {\r\n            ...trackRoute,\r\n            nodes: newNodesAndSegments.nodes,\r\n            segments: newNodesAndSegments.segments\r\n        }\r\n    })\r\n}\r\n\r\nfunction doRemoveSegment(state, action) {\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.id != action.payload.trackID) {\r\n            return trackRoute\r\n        }\r\n\r\n        let outObj = removeSegmentsFromTrackRoute(trackRoute.nodes, trackRoute.segments, [action.payload.id])\r\n\r\n        return {\r\n            ...trackRoute,\r\n            nodes: outObj.nodes,\r\n            segments: outObj.segments\r\n        }\r\n    })\r\n}\r\n\r\nexport function removeSegmentsFromTrackRoute(nodes, segments, segmentIDs) {\r\n    let removeNodeIds = getNodesThatOnlyGivenSegmentsConnectTo(\r\n        segmentIDs,\r\n        segments,\r\n        false,\r\n        true\r\n    )\r\n\r\n    let newNodes = filterOutByIds(nodes, removeNodeIds)\r\n\r\n    let newSegments = filterOutByIds(segments, segmentIDs)\r\n\r\n    return {\r\n        nodes: newNodes,\r\n        segments: newSegments\r\n    }\r\n}\r\n\r\nfunction doRestoreSegment(state, action) {\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.id != action.payload.trackID) {\r\n            return trackRoute\r\n        }\r\n        let outObj = restoreSegmentsAndNodes(trackRoute.nodes, trackRoute.segments, action.payload.nodesToRestore, [action.payload.segmentToRestore])\r\n\r\n        return {\r\n            ...trackRoute,\r\n            nodes: outObj.nodes,\r\n            segments: outObj.segments\r\n        }\r\n    })\r\n}\r\n\r\nfunction restoreSegmentsAndNodes(nodes, segments, nodesToRestore, segmentsToRestore) {\r\n    let newNodes = nodes.slice()\r\n    let newSegments = segments.slice()\r\n\r\n    for (var i = 0; i < nodesToRestore.length; i++) {\r\n        let node = nodesToRestore[i]\r\n        newNodes.push(node)\r\n    }\r\n    newNodes.sort(idCompareAsc)\r\n\r\n    for (var i = 0; i < segmentsToRestore.length; i++) {\r\n        let segment = segmentsToRestore[i]\r\n        newSegments.push(segment)\r\n    }\r\n    newSegments.sort(idCompareAsc)\r\n\r\n    return {\r\n        nodes: newNodes,\r\n        segments: newSegments\r\n    }\r\n}\r\n\r\nfunction doMoveNode(state, action) {\r\n\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.id != action.payload.trackID) {\r\n            return trackRoute\r\n        }\r\n        return {\r\n            ...trackRoute,\r\n            nodes: moveSpecificNode(\r\n                action.payload.latitude,\r\n                action.payload.longitude,\r\n                action.payload.id,\r\n                trackRoute.nodes\r\n            )\r\n        }\r\n    })\r\n}\r\n\r\nfunction doMoveStation(state, action) {\r\n    return state.map(trackRoute => {\r\n        if (trackRoute.stationIDs[0] != action.payload.id &&\r\n            trackRoute.stationIDs[1] != action.payload.id) {\r\n            return trackRoute\r\n        }\r\n        else if (trackRoute.stationIDs[0] == action.payload.id) {\r\n            return {\r\n                ...trackRoute,\r\n                nodes: moveSpecificNode(\r\n                    action.payload.latitude,\r\n                    action.payload.longitude,\r\n                    0,\r\n                    trackRoute.nodes\r\n                )\r\n            }\r\n        }\r\n        else if (trackRoute.stationIDs[1] == action.payload.id) {\r\n            return {\r\n                ...trackRoute,\r\n                nodes: moveSpecificNode(\r\n                    action.payload.latitude,\r\n                    action.payload.longitude,\r\n                    1,\r\n                    trackRoute.nodes\r\n                )\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfunction moveSpecificNode(latitude, longitude, id, nodes) {\r\n    let newNodes = nodes.map(item => {\r\n        if (item.id != id) {\r\n            return item\r\n        }\r\n        return {\r\n            ...item,\r\n            latitude: latitude,\r\n            longitude: longitude\r\n        }\r\n    })\r\n\r\n    return newNodes.sort(idCompareAsc)\r\n}\r\n\r\nexport function getTrackIDsByStationID(tracks, stationID, includeDeleted) {\r\n    let output = tracks.filter(track => {\r\n        return track.stationIDs[0] === stationID ||\r\n            track.stationIDs[1] === stationID\r\n    }).map(track => {\r\n        return track.id\r\n    })\r\n    return filterDeleted(output, includeDeleted)\r\n}\r\n\r\nexport function getNodesThatOnlyGivenSegmentsConnectTo(segmentIDs, fullset, includeStationNodes, includeControlPoint) {\r\n\r\n    let segmentIDSet = new Set(segmentIDs)\r\n    let subsetNodeIds = []\r\n\r\n    let differenceSetNodeIds = []\r\n\r\n    fullset.forEach(segment => {\r\n        if (segmentIDSet.has(segment.id)) {\r\n            subsetNodeIds.push(segment.endNodes[0])\r\n            subsetNodeIds.push(segment.endNodes[1])\r\n            if (includeControlPoint && segment.controlPoint) {\r\n                subsetNodeIds.push(segment.controlPoint)\r\n            }\r\n        } else {\r\n            differenceSetNodeIds.push(segment.endNodes[0])\r\n            differenceSetNodeIds.push(segment.endNodes[1])\r\n            if (includeControlPoint && segment.controlPoint) {\r\n                differenceSetNodeIds.push(segment.controlPoint)\r\n            }\r\n        }\r\n    })\r\n\r\n    let subsetOnlyNodeIds = difference(\r\n        subsetNodeIds,\r\n        differenceSetNodeIds\r\n    )\r\n\r\n    if (includeStationNodes == false) {\r\n        let checkSet = new Set(subsetOnlyNodeIds)\r\n        checkSet.delete(0)\r\n        checkSet.delete(1)\r\n        return Array.from(checkSet)\r\n    }\r\n\r\n    return subsetOnlyNodeIds\r\n}\r\n\r\nexport function getCommonEndPointsBetweenTwoSegments(segmentA_ID, segmentB_ID, fullset) {\r\n    let segmentANodes = getById(fullset, segmentA_ID).endNodes\r\n    let segmentBNodes = getById(fullset, segmentB_ID).endNodes\r\n\r\n    return intersection(segmentANodes, segmentBNodes)\r\n}\r\n\r\nexport function getUnCommonEndPointsBetweenTwoSegments(segmentA_ID, segmentB_ID, fullset) {\r\n    let segmentANodes = getById(fullset, segmentA_ID).endNodes\r\n    let segmentBNodes = getById(fullset, segmentB_ID).endNodes\r\n\r\n    let commonNodes = intersection(segmentANodes, segmentBNodes)\r\n    let allNodes = union(segmentANodes, segmentBNodes)\r\n    return difference(allNodes, commonNodes)\r\n}\r\n","E:\\Projects\\metro_maker\\src\\reducers\\transferReducer.js",["171","172","173","174"],"import _ from 'underscore';\r\nimport { filterDeleted, filterOutById, genericMultiDelete, genericMultiRestore, genericSingleDelete, genericSingleRestore, nextIDForArray } from '../utils/utils'\r\n\r\nimport {\r\n    ADD_TRANSFER,\r\n    UNDO_ADD_TRANSFER,\r\n    EDIT_TRANSFER,\r\n    REMOVE_TRANSFER,\r\n    RESTORE_TRANSFER,\r\n    REMOVE_STATION,\r\n    RESTORE_STATION,\r\n} from '../actions/actionTypes'\r\n\r\nconst initialState = []\r\n\r\nexport default function transferReducer(state = initialState, action) {\r\n    switch (action.type) {\r\n        case ADD_TRANSFER: {\r\n            return doAddTransfer(state, action);\r\n        }\r\n        case UNDO_ADD_TRANSFER: {\r\n            return filterOutById(state, action.payload.id);\r\n        }\r\n        case EDIT_TRANSFER: {\r\n            return doEditTransfer(state, action);\r\n        }\r\n        case REMOVE_STATION: {\r\n            return genericMultiDelete(\r\n                state,\r\n                action.payload.transferIDs,\r\n                action.payload.deletedAt\r\n            )\r\n        }\r\n        case REMOVE_TRANSFER: {\r\n            return genericSingleDelete(\r\n                state,\r\n                action.payload.id,\r\n                action.payload.deletedAt)\r\n        }\r\n        case RESTORE_STATION: {\r\n            return genericMultiRestore(\r\n                state,\r\n                action.payload.transferIDs,\r\n            )\r\n        }\r\n        case RESTORE_TRANSFER: {\r\n            return genericSingleRestore(\r\n                state,\r\n                action.payload.id\r\n            )\r\n        }\r\n        default: {\r\n            return state\r\n        }\r\n    }\r\n}\r\n\r\nfunction doAddTransfer(state, action) {\r\n    return [\r\n        ...state,\r\n        {\r\n            id: nextIDForArray(state),\r\n            stationIDs: action.payload.stationIDs,\r\n            type: action.payload.type,\r\n            deletedAt: null\r\n        }\r\n    ]\r\n}\r\n\r\nfunction doEditTransfer(state, action) {\r\n    return state.map(item => {\r\n        if (item.id != action.payload.id) {\r\n            return item\r\n        }\r\n        return {\r\n            ...item,\r\n            type: action.payload.type,\r\n        }\r\n    })\r\n}\r\n\r\nexport function selectAllConnectedStations(state, stationID) {\r\n    //for each transfer, create hashmap of station to station\r\n    //then do a BFS search\r\n\r\n    let map = new Map();\r\n    state.foreach(element => {\r\n        let A = element.stationIDs[0];\r\n        let B = element.stationIDs[1];\r\n\r\n        if (!map.has(A)) {\r\n            map.set(A, [B]);\r\n        } else if (!map.get(A).includes(B)) {\r\n            map.get(A).push(B);\r\n        }\r\n\r\n        if (!map.has(B)) {\r\n            map.set(B, [A]);\r\n        } else if (!map.get(B).includes(A)) {\r\n            map.get(B).push(A);\r\n        }\r\n    })\r\n\r\n    let connectedIDs = [];\r\n    let searchQueue = [];\r\n\r\n    searchQueue.push(stationID);\r\n    while (searchQueue.length() > 0) {\r\n        let cur = searchQueue.shift();\r\n\r\n        let connected = map.get(cur);\r\n        connected.foreach(element => {\r\n            searchQueue.push(element);\r\n            connectedIDs.push(element);\r\n        })\r\n    }\r\n\r\n    return connectedIDs\r\n}\r\n\r\nexport function selectAllTransfersGivenStationID(transfers, stationID, includeDeleted) {\r\n    let output = transfers.filter(transfer => {\r\n        return (transfer.stationIDs[0] == stationID || transfer.stationIDs[1] == stationID)\r\n    })\r\n    return filterDeleted(output, includeDeleted)\r\n}\r\n\r\nexport function transferIDsGivenStationID(transfers, stationID, includeDeleted) {\r\n    return selectAllTransfersGivenStationID(transfers, stationID, includeDeleted).map(transfer => {\r\n        return transfer.id\r\n    })\r\n}\r\n","E:\\Projects\\metro_maker\\src\\components\\managementPanel.js",["175","176","177"],"E:\\Projects\\metro_maker\\src\\components\\colorPickerButton.js",[],"E:\\Projects\\metro_maker\\src\\components\\colorPickerPopup.js",[],"E:\\Projects\\metro_maker\\src\\components\\addAgency.js",[],"E:\\Projects\\metro_maker\\src\\components\\agencyItem.js",[],{"ruleId":"178","severity":1,"message":"179","line":5,"column":8,"nodeType":"180","messageId":"181","endLine":5,"endColumn":23},{"ruleId":"178","severity":1,"message":"182","line":9,"column":9,"nodeType":"180","messageId":"181","endLine":9,"endColumn":51},{"ruleId":"178","severity":1,"message":"183","line":9,"column":52,"nodeType":"180","messageId":"181","endLine":9,"endColumn":86},{"ruleId":"178","severity":1,"message":"184","line":9,"column":87,"nodeType":"180","messageId":"181","endLine":9,"endColumn":113},{"ruleId":"178","severity":1,"message":"185","line":10,"column":10,"nodeType":"180","messageId":"181","endLine":10,"endColumn":19},{"ruleId":"178","severity":1,"message":"186","line":10,"column":21,"nodeType":"180","messageId":"181","endLine":10,"endColumn":31},{"ruleId":"178","severity":1,"message":"187","line":10,"column":33,"nodeType":"180","messageId":"181","endLine":10,"endColumn":45},{"ruleId":"178","severity":1,"message":"188","line":10,"column":47,"nodeType":"180","messageId":"181","endLine":10,"endColumn":60},{"ruleId":"178","severity":1,"message":"189","line":11,"column":10,"nodeType":"180","messageId":"181","endLine":11,"endColumn":17},{"ruleId":"178","severity":1,"message":"190","line":11,"column":19,"nodeType":"180","messageId":"181","endLine":11,"endColumn":27},{"ruleId":"178","severity":1,"message":"191","line":11,"column":29,"nodeType":"180","messageId":"181","endLine":11,"endColumn":39},{"ruleId":"178","severity":1,"message":"192","line":11,"column":41,"nodeType":"180","messageId":"181","endLine":11,"endColumn":52},{"ruleId":"178","severity":1,"message":"193","line":12,"column":10,"nodeType":"180","messageId":"181","endLine":12,"endColumn":20},{"ruleId":"178","severity":1,"message":"194","line":12,"column":22,"nodeType":"180","messageId":"181","endLine":12,"endColumn":33},{"ruleId":"178","severity":1,"message":"195","line":12,"column":35,"nodeType":"180","messageId":"181","endLine":12,"endColumn":48},{"ruleId":"178","severity":1,"message":"196","line":12,"column":50,"nodeType":"180","messageId":"181","endLine":12,"endColumn":64},{"ruleId":"178","severity":1,"message":"197","line":13,"column":9,"nodeType":"180","messageId":"181","endLine":13,"endColumn":22},{"ruleId":"178","severity":1,"message":"198","line":13,"column":24,"nodeType":"180","messageId":"181","endLine":13,"endColumn":38},{"ruleId":"178","severity":1,"message":"199","line":14,"column":10,"nodeType":"180","messageId":"181","endLine":14,"endColumn":35},{"ruleId":"178","severity":1,"message":"200","line":14,"column":36,"nodeType":"180","messageId":"181","endLine":14,"endColumn":63},{"ruleId":"178","severity":1,"message":"201","line":14,"column":64,"nodeType":"180","messageId":"181","endLine":14,"endColumn":87},{"ruleId":"178","severity":1,"message":"202","line":16,"column":10,"nodeType":"180","messageId":"181","endLine":16,"endColumn":30},{"ruleId":"178","severity":1,"message":"203","line":16,"column":31,"nodeType":"180","messageId":"181","endLine":16,"endColumn":55},{"ruleId":"204","replacedBy":"205"},{"ruleId":"206","replacedBy":"207"},{"ruleId":"178","severity":1,"message":"208","line":1,"column":17,"nodeType":"180","messageId":"181","endLine":1,"endColumn":25},{"ruleId":"178","severity":1,"message":"209","line":2,"column":10,"nodeType":"180","messageId":"181","endLine":2,"endColumn":21},{"ruleId":"178","severity":1,"message":"210","line":2,"column":23,"nodeType":"180","messageId":"181","endLine":2,"endColumn":34},{"ruleId":"211","severity":1,"message":"212","line":72,"column":21,"nodeType":"213","messageId":"214","endLine":72,"endColumn":23},{"ruleId":"178","severity":1,"message":"215","line":4,"column":5,"nodeType":"180","messageId":"181","endLine":4,"endColumn":16},{"ruleId":"211","severity":1,"message":"216","line":94,"column":31,"nodeType":"213","messageId":"214","endLine":94,"endColumn":33},{"ruleId":"211","severity":1,"message":"216","line":91,"column":24,"nodeType":"213","messageId":"214","endLine":91,"endColumn":26},{"ruleId":"178","severity":1,"message":"217","line":134,"column":11,"nodeType":"180","messageId":"181","endLine":134,"endColumn":12},{"ruleId":"178","severity":1,"message":"198","line":1,"column":106,"nodeType":"180","messageId":"181","endLine":1,"endColumn":120},{"ruleId":"178","severity":1,"message":"218","line":18,"column":8,"nodeType":"180","messageId":"181","endLine":18,"endColumn":9},{"ruleId":"178","severity":1,"message":"219","line":438,"column":10,"nodeType":"180","messageId":"181","endLine":438,"endColumn":37},{"ruleId":"211","severity":1,"message":"216","line":458,"column":44,"nodeType":"213","messageId":"214","endLine":458,"endColumn":46},{"ruleId":"178","severity":1,"message":"220","line":487,"column":10,"nodeType":"180","messageId":"181","endLine":487,"endColumn":32},{"ruleId":"178","severity":1,"message":"221","line":492,"column":10,"nodeType":"180","messageId":"181","endLine":492,"endColumn":28},{"ruleId":"211","severity":1,"message":"216","line":498,"column":35,"nodeType":"213","messageId":"214","endLine":498,"endColumn":37},{"ruleId":"211","severity":1,"message":"216","line":498,"column":68,"nodeType":"213","messageId":"214","endLine":498,"endColumn":70},{"ruleId":"211","severity":1,"message":"216","line":504,"column":29,"nodeType":"213","messageId":"214","endLine":504,"endColumn":31},{"ruleId":"178","severity":1,"message":"222","line":1,"column":36,"nodeType":"180","messageId":"181","endLine":1,"endColumn":42},{"ruleId":"211","severity":1,"message":"212","line":168,"column":27,"nodeType":"213","messageId":"214","endLine":168,"endColumn":29},{"ruleId":"211","severity":1,"message":"212","line":215,"column":27,"nodeType":"213","messageId":"214","endLine":215,"endColumn":29},{"ruleId":"211","severity":1,"message":"212","line":239,"column":32,"nodeType":"213","messageId":"214","endLine":239,"endColumn":34},{"ruleId":"211","severity":1,"message":"212","line":250,"column":32,"nodeType":"213","messageId":"214","endLine":250,"endColumn":34},{"ruleId":"211","severity":1,"message":"212","line":270,"column":27,"nodeType":"213","messageId":"214","endLine":270,"endColumn":29},{"ruleId":"211","severity":1,"message":"212","line":294,"column":27,"nodeType":"213","messageId":"214","endLine":294,"endColumn":29},{"ruleId":"211","severity":1,"message":"212","line":351,"column":27,"nodeType":"213","messageId":"214","endLine":351,"endColumn":29},{"ruleId":"211","severity":1,"message":"212","line":380,"column":27,"nodeType":"213","messageId":"214","endLine":380,"endColumn":29},{"ruleId":"211","severity":1,"message":"212","line":391,"column":32,"nodeType":"213","messageId":"214","endLine":391,"endColumn":34},{"ruleId":"211","severity":1,"message":"212","line":430,"column":27,"nodeType":"213","messageId":"214","endLine":430,"endColumn":29},{"ruleId":"211","severity":1,"message":"212","line":456,"column":27,"nodeType":"213","messageId":"214","endLine":456,"endColumn":29},{"ruleId":"211","severity":1,"message":"212","line":490,"column":27,"nodeType":"213","messageId":"214","endLine":490,"endColumn":29},{"ruleId":"223","severity":1,"message":"224","line":513,"column":14,"nodeType":"180","messageId":"225","endLine":513,"endColumn":15},{"ruleId":"211","severity":1,"message":"212","line":528,"column":27,"nodeType":"213","messageId":"214","endLine":528,"endColumn":29},{"ruleId":"226","severity":1,"message":"227","line":544,"column":33,"nodeType":"228","messageId":"229","endLine":544,"endColumn":35},{"ruleId":"211","severity":1,"message":"212","line":545,"column":38,"nodeType":"213","messageId":"214","endLine":545,"endColumn":40},{"ruleId":"211","severity":1,"message":"212","line":546,"column":38,"nodeType":"213","messageId":"214","endLine":546,"endColumn":40},{"ruleId":"211","severity":1,"message":"216","line":549,"column":43,"nodeType":"213","messageId":"214","endLine":549,"endColumn":45},{"ruleId":"211","severity":1,"message":"216","line":560,"column":43,"nodeType":"213","messageId":"214","endLine":560,"endColumn":45},{"ruleId":"211","severity":1,"message":"212","line":576,"column":21,"nodeType":"213","messageId":"214","endLine":576,"endColumn":23},{"ruleId":"211","severity":1,"message":"216","line":627,"column":29,"nodeType":"213","messageId":"214","endLine":627,"endColumn":31},{"ruleId":"178","severity":1,"message":"218","line":1,"column":8,"nodeType":"180","messageId":"181","endLine":1,"endColumn":9},{"ruleId":"211","severity":1,"message":"212","line":72,"column":21,"nodeType":"213","messageId":"214","endLine":72,"endColumn":23},{"ruleId":"211","severity":1,"message":"216","line":123,"column":40,"nodeType":"213","messageId":"214","endLine":123,"endColumn":42},{"ruleId":"211","severity":1,"message":"216","line":123,"column":79,"nodeType":"213","messageId":"214","endLine":123,"endColumn":81},{"ruleId":"178","severity":1,"message":"208","line":1,"column":17,"nodeType":"180","messageId":"181","endLine":1,"endColumn":25},{"ruleId":"178","severity":1,"message":"230","line":3,"column":8,"nodeType":"180","messageId":"181","endLine":3,"endColumn":25},{"ruleId":"231","severity":1,"message":"232","line":11,"column":5,"nodeType":"233","messageId":"234","endLine":13,"endColumn":6},"no-unused-vars","'reportWebVitals' is defined but never used.","Identifier","unusedVar","'selectAgenciesLinesAndServicesAsTreeObject' is defined but never used.","'selectLinesAndServicesAsTreeObject' is defined but never used.","'selectServicesAsTreeObject' is defined but never used.","'addAgency' is defined but never used.","'editAgency' is defined but never used.","'removeAgency' is defined but never used.","'restoreAgency' is defined but never used.","'addLine' is defined but never used.","'editLine' is defined but never used.","'removeLine' is defined but never used.","'restoreLine' is defined but never used.","'addService' is defined but never used.","'editService' is defined but never used.","'removeService' is defined but never used.","'restoreService' is defined but never used.","'filterDeleted' is defined but never used.","'nextIDForArray' is defined but never used.","'selectServicesGivenLineID' is defined but never used.","'selectServicesGivenAgencyID' is defined but never used.","'serviceIDsGivenAgencyID' is defined but never used.","'lineIDsGivenAgencyId' is defined but never used.","'selectLinesGivenAgencyId' is defined but never used.","no-native-reassign",["235"],"no-negated-in-lhs",["236"],"'useState' is defined but never used.","'useSelector' is defined but never used.","'useDispatch' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","'ADD_SERVICE' is defined but never used.","Expected '===' and instead saw '=='.","'R' is assigned a value but never used.","'_' is defined but never used.","'validActionsForServiceRoute' is defined but never used.","'isServiceRouteComplete' is defined but never used.","'getStationsInOrder' is defined but never used.","'object' is defined but never used.","no-redeclare","'i' is already defined.","redeclared","array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","'ColorPickerButton' is defined but never used.","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-global-assign","no-unsafe-negation"]